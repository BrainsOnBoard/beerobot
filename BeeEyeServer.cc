
#include "BeeEyeServer.h"

#include "HttpServer.h"

#include <iostream>
#include <fstream>

// opencv includes
// (note that the program won't work with older versions of opencv v2;
// all versions of opencv v3 should be fine)
#include <opencv2/opencv.hpp>
#include <opencv2/highgui/highgui.hpp>

// bee-eye pixel map generated by gigerommatidiamodel.py
#include "gigerdatacam.h"

using namespace std;
using namespace cv;

#define VIDEO_DEV get_camera_by_name("PIXPRO SP360 4K")
#define LISTEN_PORT 1234

BeeEyeServer::BeeEyeServer()
: HttpServer(LISTEN_PORT), cap(VIDEO_DEV) {
    // to capture webcam output
    if (!this->cap.isOpened()) {
        cerr << "Error: Could not open webcam (" << VIDEO_DEV << ")" << endl;
        exit(1);
    }

    // set resolution
    this->cap.set(CAP_PROP_FRAME_WIDTH, this->params.ssrc.width);
    this->cap.set(CAP_PROP_FRAME_HEIGHT, this->params.ssrc.height);

    // create x and y pixel maps
    Size sz_out(eye_size[0], eye_size[1]);
    this->map_x.create(sz_out, CV_32FC1);
    this->map_y.create(sz_out, CV_32FC1);
    for (int i = 0; i < gdataLength; i++) {
        // left eye
        this->map_x.at<float>(gdata[i][3], 15 + gdata[i][2]) = floor(gdata[i][0]);
        this->map_y.at<float>(gdata[i][3], 15 + gdata[i][2]) = floor(gdata[i][1]);

        // right eye
        this->map_x.at<float>(gdata[i][3], 720 - 316 - eye_size[0] - gdata[i][2]) = gim_size[0] - floor(gdata[i][0]);
        this->map_y.at<float>(gdata[i][3], 720 - 316 - eye_size[0] - gdata[i][2]) = floor(gdata[i][1]);
    }

    // create pixel maps for unwrapping panoramic images
    this->params.generate_map();
}

/*BeeEyeServer::BeeEyeServer(const BeeEyeServer& orig) {
}

BeeEyeServer::~BeeEyeServer() {
}*/

void BeeEyeServer::handle_request(int connfd, char* path) {
    cout << "CONNECTION: " << connfd << endl;
    cout << "PATH: " << path << endl << endl;

    if (strcmp(path, "/") == 0) {
        ifstream fs("index.html");
        if (fs.is_open()) {
            // get file length
            fs.seekg(0, ios::end);
            int length = fs.tellg();
            fs.seekg(0, ios::beg);
            
            // read file into buffer
            char buff[length];
            fs.read(buff, length);
            
            // send along to client along with HTTP header
            const string header = "HTTP/1.1 200 OK\r\n"
                    "Content-type: text/html\r\n"
                    "Content-length: " + to_string(length) + "\r\n\r\n";
            if (send(connfd, header.c_str(), header.length(), MSG_NOSIGNAL) == -1 ||
                send(connfd, buff, length, MSG_NOSIGNAL) == -1) {
                cerr << "Error writing" << endl;
            }
        }
    } else if (strcmp(path, "/stream.mjpg") == 0) {
        const char* msg = "HTTP/1.1 200 OK\r\n"
                "Content-Type: multipart/x-mixed-replace;boundary=--jpegboundary\r\n"
                "Content-Encoding: identity\r\n"
                "Cache-Control: no-cache\r\n"
                "Max-Age: 0\r\n"
                "Expires: 0\r\n"
                "Pragma: no-cache\r\n"
                "Connection: close\r\n\r\n";
        if (send(connfd, msg, strlen(msg), MSG_NOSIGNAL) == -1) {
            cerr << "Error writing" << endl;
            goto close;
        }
        //cout << "wrote header" << endl;

        // for the bee-eye transformation
        Size sz_out(eye_size[0], eye_size[1]);
        Mat dst_eye;
        dst_eye.create(sz_out, CV_8UC3);
       
        // ultimate output size, after the unwrapping and bee-eye transformations
        Size sz(970, 1046);

        // input and final output image matrices
        Mat src, disp;
        Mat dst(this->params.sdst, CV_8UC3);
        vector<uchar> buff;
        for (;;) {
            this->cap >> src;
            if (src.size().width == 0) {
                cerr << "Error: Could not read from webcam" << endl;
                goto close;
            }
            
            /* perform two transformations:
             * - unwrap panoramic image
             * - bee eye
             * 
             * (this could be done in a single step with the correct pixel map, but 
             * this way is easier for now and works...) */
            remap(src, dst, this->params.map_x, this->params.map_y, INTER_NEAREST);
            remap(dst, dst_eye, this->map_x, this->map_y, INTER_NEAREST);

            // resize the image we get out so it's large enough to see properly
            resize(dst_eye, disp, sz, 0, 0, INTER_LINEAR);

            // convert image to JPEG; store in buff
            imencode(".jpg", disp, buff);

            // send a header + JPEG data
            const string header = "--jpegboundary\r\n"
                    "Content-Type: image/jpeg\r\n"
                    "Content-Length: " + to_string(buff.size()) + "\r\n\r\n";
            //cout << header;
            char bigbuff[header.length() + buff.size()];
            strcpy(bigbuff, header.c_str());
            int val = send(connfd, header.c_str(), header.length(), MSG_NOSIGNAL);
            if (val == -1) {
                cerr << "Error writing JPEG header" << endl;
                break;
            }
            //cout << "len: " << header.length() << "; val: " << val << endl;
            if (send(connfd, buff.data(), buff.size(), MSG_NOSIGNAL) == -1) {
                cerr << "Error writing JPEG data" << endl;
                break;
            }
        }
    } else {
        const char* msg = "HTTP/1.1 404 Not Found\r\n\r\n";
        send(connfd, msg, strlen(msg), MSG_NOSIGNAL);
    }
    
    if (errno != 0) {
        cerr << "Got error " << errno << endl;
    }
    
    close:
    //close(connfd);
    cout << "done" << endl;
}

BeeEyeServer BeeEyeServer::Instance;

void BeeEyeServer::run_server() {
    BeeEyeServer::Instance.run();
}

void BeeEyeServer::run() {
    serve(&handle_request_server);
}

void BeeEyeServer::handle_request_server(int connfd, char* path) {
    BeeEyeServer::Instance.handle_request(connfd, path);
}

int get_camera_by_name(const char* name) {
    char cname[4096];

    // iterate through devices video0, video1 etc. reading the device name from sysfs
    // until the correct device is found
    for (int i = 0;; i++) {
        string vfn = "/sys/class/video4linux/video" + to_string(i) + "/name";
        ifstream file(vfn, ios::in);
        if (!file.is_open()) {
            cout << "Warning: Could not find video device " << name << ". Using default instead." << endl;
            return 0;
        }

        file.read(cname, sizeof (cname));
        cname[file.gcount() - 1] = 0; // delete the last char, which is always newline
        file.close();

        if (strcmp(name, cname) == 0) { // we've found the correct device
            return i;
        }
    }
}